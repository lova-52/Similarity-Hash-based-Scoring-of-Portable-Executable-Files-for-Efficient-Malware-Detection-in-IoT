import ssdeep

def calculate_det_rates(dataset_I, dataset_II):   
    # Initialize detection rates
    Det_Rates = {'Imp_H': [0, 0, 0, 0], 'Pe_H': [0, 0, 0, 0], 'Sd_H': [0, 0, 0, 0], 'RSd_H': [0, 0, 0, 0]}
    # Loop through all files in Dataset II
    for index, row in dataset_II.iterrows():
        print(index)
        # Get file hashes from Dataset II
        Imp_H = row['Imp_H']
        Pe_H = row['Pe_H']
        Sd_H = row['Sd_H']
        RSd_H = row['RSd_H']
        Class = row['Class']
    
        # Query Dataset I for each hash type and update HFlag_set
        HFlag_set = {'Imp_H': set(), 'Pe_H': set(), 'Sd_H': set(), 'RSd_H': set()}
    
        # Query Dataset I for ImpHash
        result = dataset_I.loc[dataset_I['Imp_H'] == Imp_H, 'File_name'].values
        if result.size > 0:
            HFlag_set['Imp_H'].add(result[0])
    
        # Query Dataset I for PeHash

        result = dataset_I.loc[dataset_I['Pe_H'] == Pe_H, 'File_name'].values
        if result.size > 0:
            HFlag_set['Pe_H'].add(result[0])
    
        # Query Dataset I for SdHash
        try:
            results = dataset_I.loc[dataset_I['Sd_H'].apply(lambda x: ssdeep.compare(x, Sd_H) > 0)]
            for result in results.iterrows():
                HFlag_set['Sd_H'].add(result[1]['File_name'])
        except:
            for result in results.iterrows():
                HFlag_set['Sd_H'].add(result[1]['File_name'])
    
        # Query Dataset I for RSdHash
        try:
            results = dataset_I.loc[dataset_I['RSd_H'].apply(lambda x: ssdeep.compare(x, RSd_H) > 0)]
            for result in results.iterrows():
                HFlag_set['RSd_H'].add(result[1]['File_name'])
        except:
            for result in results.iterrows():
                HFlag_set['Sd_H'].add(result[1]['File_name'])
    
        # Update detection rates based on class
        if Class == 'Malicious':  # Malware file
            for hash_type in Det_Rates.keys():
                if len(HFlag_set[hash_type]) > 0:
                    Det_Rates[hash_type][0] += 1  # True positive
                else:
                    Det_Rates[hash_type][1] += 1  # False negative
        else:  # Clean file
            for hash_type in Det_Rates.keys():
                if len(HFlag_set[hash_type]) > 0:
                    Det_Rates[hash_type][2] += 1  # False positive
                else:
                    Det_Rates[hash_type][3] += 1  # True negative

    # Print detection rates
    print(Det_Rates)
    print("Press any key to continue...")
    input()
    return Det_Rates


#Step 4
def calculate_cfi(det_rates, total_sameples):
    cfi = {}

    # Calculate the sum of TDRs for all hash methods
    sum_tdr = 0
    for hash_method in det_rates.keys():
        sum_tdr += (det_rates[hash_method][0] + det_rates[hash_method][3])/total_sameples

    # Loop over the hash methods and calculate their CFI values
    for hash_method in det_rates.keys():
        # Calculate the CFI value for the hash method
        cfi[hash_method] = round((sum_tdr**(-1) * ((det_rates[hash_method][0] + det_rates[hash_method][3])/total_sameples)), 3)

    return cfi

def calculate_recall(det_rates):
    #Store Recall values for each hash mothod
    recall = {}
    
    # Loop over the hash methods and calculate their Recall value
    for hash_method in det_rates.keys():
        # Calculate the Recall value for the hash method
        recall[hash_method] = round( (det_rates[hash_method][0]/(det_rates[hash_method][0] + det_rates[hash_method][1])), 3)
    
    return recall

def calculate_ppv(det_rates):
    #Store PPV values for each hash mothod
    ppv = {}
    
    # Loop over the hash methods and calculate their PPV value
    for hash_method in det_rates.keys():
        # Calculate the PPV value for the hash method
        ppv[hash_method] = round( (det_rates[hash_method][0]/(det_rates[hash_method][0] + det_rates[hash_method][2])),3)
    
    return ppv

def calculate_acc(det_rates):
    #Store PPV values for each hash mothod
    acc = {}
    
    # Loop over the hash methods and calculate their PPV value
    for hash_method in det_rates.keys():
        # Calculate the PPV value for the hash method
        acc[hash_method] = round( ((det_rates[hash_method][0] + det_rates[hash_method][2])
                                   /(det_rates[hash_method][0] + det_rates[hash_method][1] + det_rates[hash_method][2] + det_rates[hash_method][3])),3)
    
    return acc

def calculate_f1(det_rates):
    #Store F1 values for each hash mothod
    f1 = {}
    
    # Loop over the hash methods and calculate their F1 value
    for hash_method in det_rates.keys():
        # Calculate the F1 value for the hash method
        ppv = round( (det_rates[hash_method][0]/(det_rates[hash_method][0] + det_rates[hash_method][2])),3)
        recall = round( (det_rates[hash_method][0]/(det_rates[hash_method][0] + det_rates[hash_method][1])),3)
        f1[hash_method] = round((2 * ppv * recall)/(ppv + recall),1)
    return f1

def calculate_tdr(det_rates, total_samples):
    #Store TDR values for each hash mothod
    tdr = {}
    
    # Loop over the hash methods and calculate their TDR value
    for hash_method in det_rates.keys():
        # Calculate the TDR value for the hash method
        tdr[hash_method] = round(((det_rates[hash_method][0] + det_rates[hash_method][2])/total_samples), 3)    
    return tdr

def calculate_fdr(det_rates, total_samples):
    #Store False Detection Rate (FDR) values for each hash mothod
    fdr = {}
    
    # Loop over the hash methods and calculate their FDR value
    for hash_method in det_rates.keys():
        # Calculate the FDR value for the hash method
        fdr[hash_method] = round(((det_rates[hash_method][1] + det_rates[hash_method][3])/total_samples), 3)      
    return fdr

def calculate_fpr(det_rates):
    #Store False Positive Rate (FPR) values for each hash mothod
    fpr = {}
    
    # Loop over the hash methods and calculate their PPV value
    for hash_method in det_rates.keys():
        # Calculate the PPV value for the hash method
        fpr[hash_method] = round((det_rates[hash_method][2]/(det_rates[hash_method][0]+det_rates[hash_method][2])), 3)    
    return fpr
